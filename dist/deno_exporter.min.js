(()=>{function e(e,t,a,n){Object.defineProperty(e,t,{get:a,set:n,enumerable:!0,configurable:!0})}var t="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof self?self:"undefined"!=typeof window?window:"undefined"!=typeof global?global:{},a={},n={},r=t.parcelRequire94c2;null==r&&((r=function(e){if(e in a)return a[e].exports;if(e in n){var t=n[e];delete n[e];var r={id:e,exports:{}};return a[e]=r,t.call(r.exports,r,r.exports),r.exports}var o=new Error("Cannot find module '"+e+"'");throw o.code="MODULE_NOT_FOUND",o}).register=function(e,t){n[e]=t},t.parcelRequire94c2=r),r.register("5h8Ic",(function(t,a){var n;n=t.exports,Object.defineProperty(n,"__esModule",{value:!0,configurable:!0}),e(t.exports,"Console",(()=>r)),e(t.exports,"FileSystem",(()=>o)),e(t.exports,"default",(()=>i));const r={},o={getCwd:()=>Deno.cwd(),__filename__(){const e=(new Error).stack.split(/\n    at ([\w\W]*?)(?::\d+:\d+|$)/g)[2];return Deno.lstatSync(e).isFile?e:null},__dirname__(){const e=(new Error).stack.split(/\n    at ([\w\W]*?)(?::\d+:\d+|$)/g)[2];return Deno.lstatSync(e).isFile?Path.dirname(e):Deno.cwd()},read:async e=>{try{return await Deno.readTextFile(file)}catch(e){return null}},info:async e=>{const t=await Deno.lstat(e).catch((()=>({doesntExist:!0})));if(t.exists=!t.doesntExist,t.exists){const a=await Deno.stat(e).catch((()=>({doesntExist:!0})));t.isFile=a.isFile,t.isDirectory=a.isDirectory}return t},remove:e=>Deno.remove(path,{recursive:!0}).catch((()=>!1)),makeAbsolute:e=>Path.isAbsolute(e)?e:Path.normalize(Path.join(Deno.cwd(),e)),clearAPathFor:async e=>{const t=Path.dirname(e);if(t==e)return;await o.clearAPathFor(t);const{exists:a,isDirectory:n}=o.info(t);a&&!n&&await o.remove(t);const r=await Deno.lstat(t).catch((()=>({doesntExist:!0})));r.exists||Deno.mkdir(Path.dirname(r),{recursive:!0})},walkUpUntil:async(e,t=null)=>{const a=Deno.cwd();let n=t||a;for(Path.isAbsolute(n)||(n=Path.join(a,e));;){let t=Path.join(n,e);if(!(await Deno.stat(t).catch((()=>({doesntExist:!0})))).doesntExist)return t;if(n==Path.dirname(n))return null;n=Path.dirname(n)}},copy:async({from:e,to:t,force:a=!0})=>{await o.clearAPathFor(t),a&&o.remove(t);const n=await Deno.open(e,{read:!0}),r=await Deno.create(t);return result=await copy(n,r),Deno.close(n.rid),Deno.close(r.rid),result},relativeLink:async({existingItem:e,newItem:t})=>(Deno.cwd(),e=Deno.relative(Deno.cwd(),Path.normalize(e)),t=Deno.relative(Deno.cwd(),Path.normalize(t)),(await Deno.stat(parentPath).catch((()=>({doesntExist:!0})))).doesntExist||(await o.clearAPathFor(t),await o.remove(t)),Deno.symlink(e,t)),listPaths:async(e,t)=>{const a=[];for await(const t of Deno.readDir(e)){const n=Path.join(e,t.name);a.push(n)}return a},recursiveFileList:async(e,t)=>{if(t.alreadySeached||(t.alreadySeached=new Set),alreadySeached.has(e))return[];const a=o.makeAbsolute(e);alreadySeached.add(a);const n=[];for await(const a of Deno.readDir(e)){const r=Path.join(e,a.name);if(a.isFile)n.push(r);else if(a.isDirectory)for(const e of await o.recursiveFileList(r,{...t,alreadySeached:alreadySeached}))n.push(e);else if(!t.onlyHardlinks&&a.isSymlink)if(t.dontFollowSymlinks)n.push(r);else if((await Deno.stat(r).catch((()=>({doesntExist:!0})))).isDirectory)for(const e of await o.recursiveFileList(r,{...t,alreadySeached:alreadySeached}))n.push(e);else n.push(r)}return n}};var i={Console:r,FileSystem:o}})),r("5h8Ic")})();